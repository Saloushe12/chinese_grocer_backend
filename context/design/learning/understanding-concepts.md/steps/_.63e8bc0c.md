---
timestamp: 'Sun Oct 19 2025 20:16:54 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251019_201654.4997e51b.md]]'
content_id: 63e8bc0c0aae187cab1d9145317962b385489310a24677df95d2d53856f5f072
---

# Syncs

### Sync: AggregateReviewRating

```
sync AggregateReviewRating
when Review.createReview(userId, storeId, text, rating)
then Rating.updateRating(storeId, { rating: rating, weight: 1 })
```

**Explanation:** This sync ensures that when a new review is successfully created, the `Rating` concept is updated to reflect the new contribution.

### Sync: CascadeReviewDeletion

```
sync CascadeReviewDeletion
when Review.deleteReview(reviewId)
where in Review: reviewId of r is reviewId
then
  // Need to update the aggregate rating before deleting the review
  Rating.updateRating(r.storeId, { rating: -r.rating, weight: -1 }) // Assuming negative rating to subtract
  // Note: A more robust implementation might involve re-calculating the average from scratch if a more complex aggregation logic is needed.
  // For now, we subtract the contribution.
```

**Explanation:** When a review is deleted, we need to adjust the aggregated rating. This sync subtracts the contribution of the deleted review. Note: Handling the actual recalculation of the average or composite rating might require a more sophisticated `updateRating` or a separate sync if direct subtraction isn't precise enough.

### Sync: TagBasedSearchOrchestration

This is an example of how features are built by orchestrating concepts. It's not a concept itself but illustrates composition.

```
// Example: Feature to find stores with a specific tag and a good rating.
// This would be implemented in the application layer or a dedicated 'Feature' concept if complexity grows.

// Conceptual flow:
// 1. User requests to find stores tagged "Chinese" with a rating >= 4.
// 2. Application (or orchestrating layer) calls: Tagging.getStoresByTag("Chinese")
// 3. For each storeId returned:
//    a. Call Store.getStore(storeId) to get the name and address.
//    b. Call Rating.getRating(storeId) to get the aggregated rating.
//    c. If aggregatedRating >= 4, include the store in the results.
```

**Explanation of Changes and Rationale:**

1. **`Store` Concept:**
   * **Purpose/Principle:** Clarified that the principle highlights the `Store` concept's foundational role, with external interactions managed via syncs. This reinforces its independence.
   * **State (`address`):** Added a comment to justify using a string for `address`. If address complexity grows, a separate `Address` concept could be introduced later, but for this scope, a string aligns with keeping concepts focused.
   * **Actions:** Added "unique document identifier" to `storeId` for clarity.

2. **`Tagging` Concept:**
   * **Purpose:** Rephrased for conciseness and to emphasize "arbitrary classification."
   * **State:** Clarified that `storeId` references a `Store`.
   * **Actions (`addTag`):** Added a note about potential validation for tags, suggesting it could be an external concern or part of a future `Tag` concept if needed, maintaining current concept independence.

3. **`Review` Concept:**
   * **Purpose:** Emphasized that this concept is *solely* responsible for individual review data. This is crucial for separation of concerns. It explicitly states that aggregate rating updates are *not* its responsibility.
   * **State:** Clarified that `storeId` and `userId` reference other concepts (assumed `Store` and `User` respectively). Added a note about `userId` assuming a `User` concept exists.
   * **Actions (`createReview`):** Explicitly stated that it *does not* update aggregate ratings, reinforcing its single responsibility. Added a requirement for a valid rating range.
   * **Actions (`deleteReview`):** This action is now only responsible for deleting the review record itself. The side-effect of updating the aggregate rating is now handled by a sync.

4. **`Rating` Concept:**
   * **Purpose:** Made more explicit that it maintains an *aggregated* score and count.
   * **State:** Renamed `rating` to `aggregatedRating` for better clarity between individual review ratings and the overall store rating.
   * **Actions (`updateRating`):**
     * Changed the signature to accept a `contribution` object (`{ rating: Number, weight: Number }`). This makes the action more flexible for handling additions (positive weight) and subtractions (negative weight) for deletions.
     * Clarified that this action is *intended* to be invoked by a synchronization mechanism, reinforcing its role as a backend service managed via syncs.
   * **Actions (`getRating`):** Modified to return both the `aggregatedRating` and `reviewCount` as they are both part of the concept's state and typically needed together.

5. **`Localization` Concept:**
   * **Purpose:** Clarified "display language" for localized content.
   * **State:** Added a note about `userId` referencing a `User` concept.
   * **Actions (`setLanguage`):** Added a requirement that `language` must be a supported locale.
   * **Actions (`getLanguage`):** Added a note about handling default languages, suggesting it can be managed by the caller.

6. **Syncs:**
   * **`UpdateRatingOnReview` Renamed to `AggregateReviewRating`:** More descriptive of its action.
   * **`AggregateReviewRating` Sync:**
     * The `when` clause correctly identifies `Review.createReview`.
     * The `then` clause now calls `Rating.updateRating` with the correct `storeId`, `rating` from the review, and a `weight` of `1` for addition.
   * **New Sync: `CascadeReviewDeletion`:**
     * This sync is crucial for maintaining data integrity and concept independence.
     * **`when Review.deleteReview(reviewId)`:** Triggers when a review is deleted.
     * **`where in Review: reviewId of r is reviewId`:** This clause is necessary to retrieve the `storeId` and `rating` of the *specific* review being deleted, as the `deleteReview` action only takes `reviewId`.
     * **`then Rating.updateRating(...)`:** Calls the `Rating` concept's `updateRating` to effectively "subtract" the deleted review's contribution. I've used a negative `rating` and `weight` for this, assuming `updateRating` can handle it. A comment is added about the need for careful implementation of `updateRating` for this subtraction.
   * **`TagBasedSearch`:** Renamed to `TagBasedSearchOrchestration` and elaborated to clearly show it's a feature built by composing concepts, not a concept itself. It demonstrates how `Tagging`, `Store`, and `Rating` actions would be used together. The "Feature queries use:" section is now presented as a conceptual flow for clarity.

These edits aim to make each concept more self-contained, clearly define its responsibilities, and leverage syncs for inter-concept communication, aligning with the principles of Concept Design.
