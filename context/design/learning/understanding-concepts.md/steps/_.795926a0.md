---
timestamp: 'Fri Nov 07 2025 21:06:03 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251107_210603.73918336.md]]'
content_id: 795926a0441315d6e549fcfab76fc06c412a36c793a381aa29ec0379a48b40dc
---

# Syncs

This section defines all synchronizations (syncs) for the application. They are grouped for clarity but would typically reside in separate `.sync.ts` files in the `src/syncs` directory.

### Internal Synchronizations (Concept-to-Concept Logic)

These syncs describe internal interactions between concepts, ensuring data consistency and implementing core features without direct user interaction.

***

### Sync: AggregateReviewRating

```
sync AggregateReviewRating
when Review.createReview(userId, storeId, text, rating)
then Rating.updateRating(storeId, { rating: rating, weight: 1 })
```

**Explanation:** This sync ensures that when a new review is successfully created, the `Rating` concept is updated to reflect the new contribution.

***

### Sync: CascadeReviewDeletion

```
sync CascadeReviewDeletion
when Review.deleteReview(reviewId)
where
  in Review: reviewId of r is reviewId // Find the review details before deletion
then
  // Adjust the aggregate rating by effectively subtracting the deleted review's contribution.
  // Note: A more robust implementation might involve re-calculating the average from scratch
  // if a more complex aggregation logic is needed or if direct subtraction leads to floating point errors.
  Rating.updateRating(r.storeId, { rating: -r.rating, weight: -1 })
```

**Explanation:** When an individual review is deleted, this sync adjusts the `Rating` concept's aggregated score to reflect the removal of that review's contribution.

***

### Sync: CascadeUserDataDeletion

```
sync CascadeUserDataDeletion
when User.deleteUser(userId)
then
  Review.deleteReviewsByUser(userId)      // Delete all reviews by the user
  Localization.clearUserLanguage(userId)  // Remove the user's language preference
  // Add other syncs here for any other concepts that might store user-specific data
```

**Explanation:** When a user account is deleted, this crucial sync ensures that associated data in other concepts is also cleaned up. This maintains data consistency and enforces referential integrity across concepts.

***

### Sync: EnsureUserExistsForReview

```
sync EnsureUserExistsForReview
when Review.createReview(userId, storeId, text, rating)
where not User.exists(userId) // Assuming User concept has an 'exists' helper action
then
  // No 'then' clause means this flow fails if the user does not exist.
  // The original Requesting.request for createReview will not receive a response.
```

**Explanation:** This sync acts as a guard. Before a review can be created, it verifies that the `userId` provided actually exists in the `User` concept. If the user does not exist, the `Review.createReview` action will not proceed, and thus no success response will be sent for the original request.

***

### External Request Handling Synchronizations (Requesting Concept Integration)

These syncs define how incoming HTTP requests (represented by `Requesting.request` actions) trigger application logic and how responses are returned.

***

### User Concept Request Syncs

#### Sync: RegisterUserRequest

```
sync RegisterUserRequest
when
  Requesting.request(path: "/User/registerUser", username, email, password) : (request)
then
  User.registerUser(username, email, password)
```

#### Sync: RegisterUserResponse

```
sync RegisterUserResponse
when
  Requesting.request(path: "/User/registerUser") : (request)
  User.registerUser() : (userId)
then
  Requesting.respond(request, userId: userId)
```

***

#### Sync: AuthenticateUserRequest

```
sync AuthenticateUserRequest
when
  Requesting.request(path: "/User/authenticateUser", usernameOrEmail, password) : (request)
then
  User.authenticateUser(usernameOrEmail, password)
```

#### Sync: AuthenticateUserResponse

```
sync AuthenticateUserResponse
when
  Requesting.request(path: "/User/authenticateUser") : (request)
  User.authenticateUser() : (userId)
then
  Requesting.respond(request, userId: userId)
```

***

#### Sync: GetUserByIdRequest

```
sync GetUserByIdRequest
when
  Requesting.request(path: "/User/_getUserById", userId) : (request)
where
  frames = await frames.query(User.getUserById, { userId }, { username, email, creationDate })
then
  Requesting.respond(request, username, email, creationDate)
```

***

#### Sync: UpdateUserEmailRequest

```
sync UpdateUserEmailRequest
when
  Requesting.request(path: "/User/updateUserEmail", userId, newEmail) : (request)
then
  User.updateUserEmail(userId, newEmail)
```

#### Sync: UpdateUserEmailResponse

```
sync UpdateUserEmailResponse
when
  Requesting.request(path: "/User/updateUserEmail") : (request)
  User.updateUserEmail() : ()
then
  Requesting.respond(request, status: "success")
```

***

#### Sync: DeleteUserRequest

```
sync DeleteUserRequest
when
  Requesting.request(path: "/User/deleteUser", userId) : (request)
then
  User.deleteUser(userId)
```

#### Sync: DeleteUserResponse

```
sync DeleteUserResponse
when
  Requesting.request(path: "/User/deleteUser") : (request)
  User.deleteUser() : ()
then
  Requesting.respond(request, status: "success")
```

***

### Store Concept Request Syncs

#### Sync: CreateStoreRequest

```
sync CreateStoreRequest
when
  Requesting.request(path: "/Store/createStore", name, address) : (request)
then
  Store.createStore(name, address)
```

#### Sync: CreateStoreResponse

```
sync CreateStoreResponse
when
  Requesting.request(path: "/Store/createStore") : (request)
  Store.createStore() : (storeId)
then
  Requesting.respond(request, storeId: storeId)
```

***

#### Sync: DeleteStoreRequest

```
sync DeleteStoreRequest
when
  Requesting.request(path: "/Store/deleteStore", storeId) : (request)
then
  Store.deleteStore(storeId)
```

#### Sync: DeleteStoreResponse

```
sync DeleteStoreResponse
when
  Requesting.request(path: "/Store/deleteStore") : (request)
  Store.deleteStore() : ()
then
  Requesting.respond(request, status: "success")
```

***

#### Sync: GetStoreRequest

```
sync GetStoreRequest
when
  Requesting.request(path: "/Store/_getStore", storeId) : (request)
where
  frames = await frames.query(Store.getStore, { storeId }, { name, address })
then
  Requesting.respond(request, name, address)
```

***

#### Sync: GetStoresByNameRequest

```
sync GetStoresByNameRequest
when
  Requesting.request(path: "/Store/_getStoresByName", name) : (request)
where
  frames = await frames.query(Store.getStoresByName, { name }, { storeId })
  return frames.collectAs([storeId], storeIds)
then
  Requesting.respond(request, storeIds: storeIds)
```

***

#### Sync: GetStoresByAddressRequest

```
sync GetStoresByAddressRequest
when
  Requesting.request(path: "/Store/_getStoresByAddress", address) : (request)
where
  frames = await frames.query(Store.getStoresByAddress, { address }, { storeId })
  return frames.collectAs([storeId], storeIds)
then
  Requesting.respond(request, storeIds: storeIds)
```

***

### Tagging Concept Request Syncs

#### Sync: AddTagRequest

```
sync AddTagRequest
when
  Requesting.request(path: "/Tagging/addTag", storeId, tag) : (request)
then
  Tagging.addTag(storeId, tag)
```

#### Sync: AddTagResponse

```
sync AddTagResponse
when
  Requesting.request(path: "/Tagging/addTag") : (request)
  Tagging.addTag() : ()
then
  Requesting.respond(request, status: "success")
```

***

#### Sync: RemoveTagRequest

```
sync RemoveTagRequest
when
  Requesting.request(path: "/Tagging/removeTag", storeId, tag) : (request)
then
  Tagging.removeTag(storeId, tag)
```

#### Sync: RemoveTagResponse

```
sync RemoveTagResponse
when
  Requesting.request(path: "/Tagging/removeTag") : (request)
  Tagging.removeTag() : ()
then
  Requesting.respond(request, status: "success")
```

***

#### Sync: GetStoresByTagRequest

```
sync GetStoresByTagRequest
when
  Requesting.request(path: "/Tagging/_getStoresByTag", tag) : (request)
where
  frames = await frames.query(Tagging.getStoresByTag, { tag }, { storeId })
  return frames.collectAs([storeId], storeIds)
then
  Requesting.respond(request, storeIds: storeIds)
```

***

### Review Concept Request Syncs

#### Sync: CreateReviewRequest

```
sync CreateReviewRequest
when
  Requesting.request(path: "/Review/createReview", userId, storeId, text, rating) : (request)
then
  Review.createReview(userId, storeId, text, rating)
```

#### Sync: CreateReviewResponse

```
sync CreateReviewResponse
when
  Requesting.request(path: "/Review/createReview") : (request)
  Review.createReview() : (reviewId)
then
  Requesting.respond(request, reviewId: reviewId)
```

***

#### Sync: DeleteReviewRequest

```
sync DeleteReviewRequest
when
  Requesting.request(path: "/Review/deleteReview", reviewId) : (request)
then
  Review.deleteReview(reviewId)
```

#### Sync: DeleteReviewResponse

```
sync DeleteReviewResponse
when
  Requesting.request(path: "/Review/deleteReview") : (request)
  Review.deleteReview() : ()
then
  Requesting.respond(request, status: "success")
```

***

#### Sync: GetReviewsForStoreRequest

```
sync GetReviewsForStoreRequest
when
  Requesting.request(path: "/Review/_getReviewsForStore", storeId) : (request)
where
  frames = await frames.query(Review.getReviewsForStore, { storeId }, { reviewId })
  return frames.collectAs([reviewId], reviewIds)
then
  Requesting.respond(request, reviewIds: reviewIds)
```

***

#### Sync: GetReviewsByUserRequest

```
sync GetReviewsByUserRequest
when
  Requesting.request(path: "/Review/_getReviewsByUser", userId) : (request)
where
  frames = await frames.query(Review.getReviewsByUser, { userId }, { reviewId })
  return frames.collectAs([reviewId], reviewIds)
then
  Requesting.respond(request, reviewIds: reviewIds)
```

***

### Rating Concept Request Syncs

#### Sync: GetRatingRequest

```
sync GetRatingRequest
when
  Requesting.request(path: "/Rating/_getRating", storeId) : (request)
where
  frames = await frames.query(Rating.getRating, { storeId }, { aggregatedRating, reviewCount })
then
  Requesting.respond(request, aggregatedRating, reviewCount)
```

***

### Localization Concept Request Syncs

#### Sync: SetLanguageRequest

```
sync SetLanguageRequest
when
  Requesting.request(path: "/Localization/setLanguage", userId, language) : (request)
then
  Localization.setLanguage(userId, language)
```

#### Sync: SetLanguageResponse

```
sync SetLanguageResponse
when
  Requesting.request(path: "/Localization/setLanguage") : (request)
  Localization.setLanguage() : ()
then
  Requesting.respond(request, status: "success")
```

***

#### Sync: GetLanguageRequest

```
sync GetLanguageRequest
when
  Requesting.request(path: "/Localization/_getLanguage", userId) : (request)
where
  frames = await frames.query(Localization.getLanguage, { userId }, { preferredLanguage })
then
  Requesting.respond(request, preferredLanguage: preferredLanguage)
```

***

### Feature Orchestration Example

This section describes how complex features are built by orchestrating multiple concepts and their actions through an application layer or dedicated feature concepts. It is not an implementable sync but illustrates composition.

#### Sync: TagBasedSearchOrchestration

```
// Example: Feature to find stores with a specific tag and a good rating.
// This would be implemented in the application layer or a dedicated 'Feature' concept if complexity grows.

// Conceptual flow (could be a sequence of syncs if complex enough):
// 1. User requests to find stores tagged "Chinese" with a rating >= 4.
// 2. An orchestrating sync captures this Requesting.request.
// 3. It then calls: Tagging.getStoresByTag("Chinese")
// 4. For each storeId returned from Tagging:
//    a. Call Store.getStore(storeId) to get the name and address.
//    b. Call Rating.getRating(storeId) to get the aggregated rating.
//    c. If aggregatedRating >= 4, include the store in the results.
// 5. Finally, Requesting.respond to the original request with the filtered list of stores.
```
