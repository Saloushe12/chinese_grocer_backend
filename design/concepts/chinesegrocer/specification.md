# Concept: User

**purpose**  
To manage user accounts, including registration, authentication, and basic profile information.

**principle**  
User accounts enable personalized interactions such as leaving reviews or setting preferences. Other concepts refer to users only by their `userId` and do not depend on internal user state.

---

## **state**

Each `User` is represented in persistent storage by the following fields:

| Field         | Type    | Description                                         |
|---------------|---------|-----------------------------------------------------|
| `userId`      | String  | Unique identifier for the user (generated by system) |
| `username`    | String  | Unique login identifier                             |
| `email`       | String  | Unique communication/login identifier               |
| `passwordHash`| String  | Secure hash of the user’s password                 |
| `creationDate`| Timestamp | Time at which the account was created           |

No other concepts may access or depend on these fields directly.

---

## **actions**

### `registerUser(username: String, email: String, password: String): { userId: String } | { error: String }`
**requires**
- `username` does not already exist in the system  
- `email` does not already exist in the system  
- `password` must be at least 8 characters long  

**effects**  
Creates a new user with a hashed password and a generated `userId`. Stores the account in persistent state.

**returns**
- `{ userId }` on success  
- `{ error }` if requirements are not met  

---

### `authenticateUser(usernameOrEmail: String, password: String): { userId: String } | { error: String }`
**requires**
- A user with the given `usernameOrEmail` must exist  
- The provided `password` must match the stored `passwordHash`  

**effects**  
Authenticates the user.

**returns**
- `{ userId }` on success  
- `{ error: "Invalid credentials." }` on failure  

---

### `getUserById(userId: String): { username: String, email: String, creationDate: Timestamp } | { error: String }`
**requires**
- The `userId` must exist  

**effects**  
Fetches non-sensitive profile information for the specified user.

**returns**
- `{ username, email, creationDate }` on success  
- `{ error }` if the user does not exist  

---

### `updateUserEmail(userId: String, newEmail: String): {} | { error: String }`
**requires**
- The `userId` must exist  
- `newEmail` must not already be in use by another user  

**effects**
- Updates the user’s email to `newEmail`.  
- If `newEmail` is the same as the current email, the action has no effect and succeeds.

**returns**
- `{}` on success  
- `{ error }` if requirements are not met  

---

### `deleteUser(userId: String): {} | { error: String }`
**requires**
- The `userId` must exist  

**effects**
- Deletes the user from persistent state.  
- (Note: cascading cleanup of associated data is not handled here, but may be implemented via syncs in future assignments.)

**returns**
- `{}` on success  
- `{ error }` if the user does not exist  

***

# Concept: Store

**purpose**
Represent the identity and physical address of a store.

**principle**
A store's existence and location are fundamental. Interactions related to its classification, user feedback, or popularity are external concerns managed by other concepts through synchronizations.

**state**
Each `Store` is represented by:

* `storeId`: String (unique document identifier)
* `name`: String
* `address`: String // A string representation is sufficient for basic identification. Complex address parsing or validation is a concern for a dedicated address concept if needed elsewhere.

**actions**

* `createStore(name: String, address: String): storeId`
  * **Requires:** No existing store has both the exact same `name` and `address`.
  * **Effect:** Creates a new store record and returns its unique `storeId`.
* `deleteStore(storeId: String)`
  * **Requires:** The `storeId` must exist.
  * **Effect:** Removes the store record.
* `getStore(storeId: String): (name: String, address: String)`
  * **Requires:** The `storeId` must exist.
  * **Effect:** Returns the `name` and `address` of the specified store.
* `getStoresByName(name: String): Set<String>`
  * **Effect:** Returns a set of all `storeId`s matching the given `name`.
* `getStoresByAddress(address: String): Set<String>`
  * **Effect:** Returns a set of all `storeId`s matching the given `address`.

***

# Concept: Tagging

**purpose**
To allow arbitrary classification of stores using descriptive tags.

**state**
Each `Tagging` record associates tags with a store:

* `storeId`: String (references a `Store`)
* `tags`: Set<String> (a collection of user-defined tags)

**actions**

* `addTag(storeId: String, tag: String)`
  * **Requires:** The `storeId` must exist. The `tag` should ideally be validated for format/content by a higher-level mechanism or a dedicated `Tag` concept if complexity arises. For now, it's a string.
  * **Effect:** Adds the specified `tag` to the `storeId`'s set of tags. If the tag already exists, the set remains unchanged.
* `removeTag(storeId: String, tag: String)`
  * **Requires:** The `storeId` must exist. The `tag` must be present in the store's tag set.
  * **Effect:** Removes the specified `tag` from the `storeId`'s set of tags.
* `getStoresByTag(tag: String): Set<String>`
  * **Effect:** Returns a set of all `storeId`s that are currently associated with the given `tag`.

***

# Concept: Review

**purpose**
To capture textual reviews and individual ratings submitted by users for specific stores. This concept is solely responsible for the *individual* review data.

**state**
Each `Review` record:

* `reviewId`: String (unique document identifier)
* `storeId`: String (references a `Store`)
* `userId`: String (references a `User`) // Now explicitly references the new User concept
* `text`: String (the content of the review)
* `rating`: Number (a specific numeric rating for this review, e.g., 1-5)

**actions**

* `createReview(userId: String, storeId: String, text: String, rating: Number): reviewId`
  * **Requires:** The `userId` must exist. The `storeId` must exist. The `rating` should be within a valid range (e.g., 1-5).
  * **Effect:** Creates a new `Review` record and returns its unique `reviewId`. This action *does not* update aggregate ratings; that is handled by a `sync`.
* `deleteReview(reviewId: String)`
  * **Requires:** The `reviewId` must exist.
  * **Effect:** Deletes the specified `Review` record.
* `getReviewsForStore(storeId: String): Set<String>`
  * **Effect:** Returns a set of all `reviewId`s associated with the specified `storeId`.
* `getReviewsByUser(userId: String): Set<String>`
  * **Effect:** Returns a set of all `reviewId`s created by the specified `userId`.

***

# Concept: Rating

**purpose**
To maintain an aggregated rating score and count for a store, derived from individual reviews.

**state**
Each `Rating` record:

* `storeId`: String (references a `Store`)
* `aggregatedRating`: Number // Represents the calculated average or composite rating.
* `reviewCount`: Number // The total number of reviews contributing to the aggregated rating.

**actions**

* `updateRating(storeId: String, contribution: { rating: Number, weight: Number })`
  * **Requires:** The `storeId` must exist. The `contribution` object contains the `rating` of a new or updated review and its `weight` (e.g., 1 for a single review).
  * **Effect:** Updates the `aggregatedRating` and increments the `reviewCount` for the `storeId` based on the provided `contribution`. This action is intended to be invoked by a synchronization mechanism.
* `getRating(storeId: String): { aggregatedRating: Number, reviewCount: Number }`
  * **Requires:** The `storeId` must exist.
  * **Effect:** Returns the current aggregated rating and the count of reviews for the store.

***

# Concept: Localization

**purpose**
To track and provide a user's preferred display language for localized content.

**state**
Each `Localization` record:

* `userId`: String (references a `User`) // Now explicitly references the new User concept
* `preferredLanguage`: String (e.g., "en", "fr", "es")

**actions**

* `setLanguage(userId: String, language: String)`
  * **Requires:** The `userId` must exist. The `language` must be a supported locale.
  * **Effect:** Sets or updates the user's preferred display language.
* `getLanguage(userId: String): String`
  * **Effect:** Returns the user's currently set preferred language. If no preference is set, a default language (e.g., "en") could be returned or handled by the calling application/sync.

***

# Syncs

### Sync: AggregateReviewRating

```
sync AggregateReviewRating
when Review.createReview(userId, storeId, text, rating)
then Rating.updateRating(storeId, { rating: rating, weight: 1 })
```

**Explanation:** This sync ensures that when a new review is successfully created, the `Rating` concept is updated to reflect the new contribution.

### Sync: CascadeReviewDeletion

```
sync CascadeReviewDeletion
when Review.deleteReview(reviewId)
where in Review: reviewId of r is reviewId
then
  // Need to update the aggregate rating before deleting the review
  Rating.updateRating(r.storeId, { rating: -r.rating, weight: -1 }) // Assuming negative rating to subtract
  // Note: A more robust implementation might involve re-calculating the average from scratch if a more complex aggregation logic is needed.
  // For now, we subtract the contribution.
```

**Explanation:** When a review is deleted, we need to adjust the aggregated rating. This sync subtracts the contribution of the deleted review. Note: Handling the actual recalculation of the average or composite rating might require a more sophisticated `updateRating` or a separate sync if direct subtraction isn't precise enough.

### Sync: CascadeUserDataDeletion

```
sync CascadeUserDataDeletion
when User.deleteUser(userId)
then
  Review.deleteReviewsByUser(userId)
  Localization.clearUserLanguage(userId)
  // Add other syncs here for any other concepts that might store user-specific data
```

**Explanation:** When a user account is deleted, this sync ensures that associated data in other concepts is cleaned up. This is crucial for data integrity and maintaining the independence of concepts by preventing orphaned records.

### Sync: EnsureUserExistsForReview

```
sync EnsureUserExistsForReview
when Review.createReview(userId, storeId, text, rating)
where not User.exists(userId) // Assuming User concept has an 'exists' helper action
then
  // Depending on desired behavior:
  // Option 1: Prevent review creation and notify.
  // Option 2: Automatically create a guest user (less ideal for explicit registration)
  // For this example, we'll assume it prevents creation and a sync error is raised.
  // No 'then' clause, so the Review.createReview action will implicitly fail or be rejected.
  // A more explicit failure could be: throw Error("User does not exist.")
```

**Explanation:** This sync acts as a guard. Before a review can be created, it verifies that the `userId` associated with the review actually exists in the `User` concept. If the user does not exist, the `Review.createReview` action effectively fails. This ensures data integrity by preventing reviews from being associated with non-existent users.

### Sync: UpdateUserEmailInReviews

```
sync UpdateUserEmailInReviews
when User.updateUserEmail(userId, newEmail)
where in Review: r.userId is userId
then
  // This sync updates the review's user information. However, reviews primarily store userId, not email.
  // This might be more relevant if reviews stored user identifiers that needed to be updated when user identifiers change.
  // For now, this is illustrative: if reviews stored user emails directly, this would update them.
  // Since reviews store userId, and userId is immutable once created, this sync is not directly applicable for email changes on userId.
  // A better example would be if a user's display name changed, and you wanted to update it on their past reviews.
  // For the current spec, this sync would be more conceptual if reviews stored more user profile info.
```

**Explanation:** This sync is a placeholder to illustrate how changes to a user's immutable identifier (like `userId` not changing, but potentially other user profile data if it were stored in `Review` directly) could be propagated. As `userId` is immutable, this sync is less directly applicable to email changes. If `Review` stored a `username` or `email` directly, this sync would be vital. Given our current `Review` structure, this sync is more conceptual.

### Sync: TagBasedSearchOrchestration

This is an example of how features are built by orchestrating concepts. It's not a concept itself but illustrates composition.

```
// Example: Feature to find stores with a specific tag and a good rating.
// This would be implemented in the application layer or a dedicated 'Feature' concept if complexity grows.

// Conceptual flow:
// 1. User requests to find stores tagged "Chinese" with a rating >= 4.
// 2. Application (or orchestrating layer) calls: Tagging.getStoresByTag("Chinese")
// 3. For each storeId returned:
//    a. Call Store.getStore(storeId) to get the name and address.
//    b. Call Rating.getRating(storeId) to get the aggregated rating.
//    c. If aggregatedRating >= 4, include the store in the results.
```

**Changes Made and Rationale for Adding the `User` Concept:**

1.  **New `User` Concept:**
    *   **Purpose:** Clearly defines the responsibility for managing user accounts, authentication, and basic profile data.
    *   **Principle:** Establishes its fundamental role in the system for personalized actions.
    *   **State:** Includes essential user attributes like `userId`, `username`, `email`, `passwordHash` (for security), and `creationDate`.
    *   **Actions:** Provides standard actions for `registerUser`, `authenticateUser`, `getUserById`, `updateUserEmail`, and `deleteUser`. These are typical operations for a user management system.

2.  **`Review` Concept Integration:**
    *   **State:** The `userId` field now explicitly references the `User` concept. This is a direct dependency.
    *   **Actions (`createReview`):** The `userId` parameter is now crucial. The `requires` clause now includes `userId must exist` to ensure reviews are linked to valid users.

3.  **`Localization` Concept Integration:**
    *   **State:** The `userId` field now explicitly references the `User` concept.
    *   **Actions (`setLanguage`, `getLanguage`):** These actions now operate on a `userId` from the `User` concept.

4.  **New Syncs for User Management:**
    *   **`CascadeUserDataDeletion`:** This is a critical sync. When a `User.deleteUser` action occurs, this sync ensures that related data in other concepts (like their reviews, localization settings) is also removed. This maintains data consistency and adheres to the principle of concepts being self-contained but orchestrable.
    *   **`EnsureUserExistsForReview`:** This sync acts as a pre-condition checker for `Review.createReview`. It verifies that the `userId` provided for a review actually corresponds to an existing user. If not, it prevents the review from being created, ensuring data integrity.
